# presentation/view/main_window.py

from PySide6.QtWidgets import QMainWindow, QLabel
from PySide6.QtCore import Qt, QTimer, QDateTime
# Import the class generated by pyuic6 from your .ui file
# Make sure this import path is correct for your project structure
from presentation.views.UI import Ui_MainWindow


class MainWindow(QMainWindow, Ui_MainWindow):  # Inherit from the generated UI class

    def __init__(self, controller=None):
        # Call QMainWindow's __init__
        super().__init__()

        # 1. Load all UI components (creates self.Program_Value_Label, self.PN_Value_LineEdit, etc.)
        self.setupUi(self)

        # Initialize controller reference (can be None initially)
        self.controller = controller

        # 2. Setup internal custom widgets and styling (only run once)
        self._setup_status_bar()
        self.update_program_name_display("", 'black')  # Set initial state for Program Name Label
        self.update_test_status("Application Initialized. Ready to scan PN.", 'black')
        self.enable_start_button(False)

        # Initialize CAN indicator styles to their default 'never hit' state (Yellow/Off)
        self._initialize_can_indicators()

        # 3. Connect UI elements if the controller is already available
        if self.controller:
            self._connect_ui()

        # 4. Start internal timers/updates
        self._start_datetime_timer()

    def set_controller(self, controller):
        """Allows the controller to be injected after the view is initialized."""
        self.controller = controller
        self._connect_ui()

    def _setup_status_bar(self):
        """Creates and attaches the permanent status label to the QStatusBar."""
        # Use the QStatusBar defined in the .ui file
        self.statusbar = self.statusBar()
        self.status_label = QLabel()

        # Style and align
        self.status_label.setAlignment(Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter)

        # Add it to the QStatusBar (stretches to fill the space)
        self.statusbar.addWidget(self.status_label)

    def _connect_ui(self):
        """Connects UI widgets to controller slots."""
        if not self.controller:
            print("Warning: Attempted to connect UI before controller was set.")
            return

        # Connect PN line edit to controller logic
        self.PN_Value_LineEdit.textChanged.connect(self.controller.handle_pn_input)

        # Connect Start button to controller logic
        self.pushButton_Start_REDO_.clicked.connect(self.controller.start_test_trigger)

    def _start_datetime_timer(self):
        """Starts a timer to update the date/time label (QLabel_DateTime)."""
        self.datetime_timer = QTimer(self)
        self.datetime_timer.timeout.connect(self._update_datetime_label)
        self.datetime_timer.start(1000)  # Update every second
        self._update_datetime_label()  # Initial call

    def _update_datetime_label(self):
        """Updates the DateTime label with current time."""
        current_datetime = QDateTime.currentDateTime().toString("yyyy-MM-dd hh:mm:ss")
        # Ensure QLabel_DateTime exists from the .ui file
        if hasattr(self, 'QLabel_DateTime'):
            self.QLabel_DateTime.setText(current_datetime)

    # --- NEW HELPER METHOD ---

    def _get_widget_by_name(self, object_name: str):
        """Helper function to retrieve a QLabel widget by its object name."""
        # The QMainWindow base class provides findChild
        widget = self.findChild(QLabel, object_name)
        if widget is None:
            print(f"Warning: QLabel with object name '{object_name}' not found.")
        return widget

    def _initialize_can_indicators(self):
        """Sets the initial (untouched) style for all indicator labels to Yellow."""
        indicator_labels = [
            "lbl_PowerMode_Off", "lbl_PowerMode_Run",
            "lbl_Wiper_Off", "lbl_Wiper_Intermittent", "lbl_Wiper_Slow"
        ]

        # Set the initial text for the current state label
        self.update_label_text("lbl_Wiper_CurrentState", "WIPER: UNKNOWN")

        # Use the update method to set initial styles (Yellow, not active)
        for name in indicator_labels:
            self.update_indicator_status(name, 'yellow', False)

    # --- UI Update Methods (Existing) ---

    def update_program_name_display(self, message: str, color: str):
        """Updates the large Program Name/PN Status label (QLabel_ProgramName)."""
        style = f"background-color: #333333; color: {color};"

        # *** CRITICAL FIX HERE ***
        # Access the correctly named QLabel from the UI file: QLabel_ProgramName
        self.QLabel_ProgramName.setText(message)

        self.QLabel_ProgramName.setStyleSheet(style)

    def update_test_status(self, message: str, color: str):
        """Updates the dynamic status bar with test progress."""
        style = f"color: {color}; font-weight: bold; padding: 2px;"
        self.status_label.setText(message)
        self.status_label.setStyleSheet(style)

    def enable_start_button(self, enabled: bool):
        """Enables or disables the Start button."""
        self.pushButton_Start_REDO_.setEnabled(enabled)

    def update_wh_result_label(self, message: str, color: str):
        """
        Updates the specific Wiring Harness test result label (Label_continuity_result)
        with the final result and color.
        """
        # 1. Define the style based on the color string passed from the Controller
        if color == 'green':
            background_color = "#388E3C"  # Dark Green
        elif color == 'red':
            background_color = "#D32F2F"  # Dark Red
        else:
            background_color = "#FFC107"  # Amber for unexpected/error

        # 2. Apply the style
        style = (
            f"background-color: {background_color}; "
            f"color: white; "
            f"font-weight: bold; "
            f"padding: 5px; "
            f"border-radius: 5px;"
        )

        # 3. Update the label text and style
        if hasattr(self, 'Label_continuity_result'):
            self.Label_continuity_result.setText(message)
            self.Label_continuity_result.setStyleSheet(style)
        else:
            print(f"UI Error: Label_continuity_result object not found. Message: {message}")

    # --- NEW UI UPDATE METHODS (Fixes AttributeErrors) ---

    def update_label_text(self, object_name: str, new_text: str, text_color: str = 'white', bg_color: str = '#333333'):
        """
        Updates the text of any QLabel by its object name, setting both foreground (text)
        and background colors.

        (Note: Added 'text_color' and 'bg_color' as arguments, default bg is dark gray).
        """
        label = self._get_widget_by_name(object_name)
        if label:
            label.setText(new_text)

            # Define specific colors based on the color string passed from the controller
            if bg_color == 'green':
                final_bg_color = "#388E3C"  # Dark Green
            elif bg_color == 'yellow':
                final_bg_color = "#FFD600"  # Bright Yellow
            else:
                final_bg_color = bg_color  # Use the default or passed color

            # Set styling
            text_style = (
                f"background-color: {final_bg_color}; "
                f"color: {text_color}; "
                f"font-weight: bold; "
                f"border: 0px;"
            )
            label.setStyleSheet(text_style)

    def update_indicator_status(self, object_name: str, hit_status_color: str, is_current_active: bool):
        """
        Handles the styling for Power Mode and Wiper state indicator labels.
        (Fixes: AttributeError: 'MainWindow' object has no attribute 'update_indicator_status')

        The controller sends the permanent color (Yellow=Never Hit, Green=Once Hit)
        and the transient state (is_current_active).
        """
        label = self._get_widget_by_name(object_name)
        if label is None:
            return

        # Define colors for the styling logic
        YELLOW = "#FFD600"  # Bright Yellow (Never Hit State)
        GREEN_BRIGHT = "#4CAF50"  # Bright Green (Currently Active)
        GREEN_DIM = "#C8E6C9"  # Pale Green (Was Hit, Not Current)
        TEXT_COLOR_DIM = "#444444"  # Dark text for pale/yellow backgrounds
        TEXT_COLOR_BRIGHT = "white"  # White text for bright green background

        # 1. Determine the permanent color state
        if hit_status_color == 'yellow':
            # Has never been achieved: MUST BE BRIGHT YELLOW
            bg_color = YELLOW
            text_color = TEXT_COLOR_DIM

        elif hit_status_color == 'green':
            if is_current_active:
                # Was achieved AND is currently active: BRIGHT GREEN
                bg_color = GREEN_BRIGHT
                text_color = TEXT_COLOR_BRIGHT
            else:
                # Was achieved, but is not current: PALE GREEN
                bg_color = GREEN_DIM
                text_color = TEXT_COLOR_DIM
        else:
            # Fallback
            bg_color = "lightgray"
            text_color = "black"

        # 2. Apply the style
        # Note: We need to use the `label` reference, not `self`.
        style = (
            f"background-color: {bg_color}; "
            f"color: {text_color}; "
            f"border: 1px solid #1c2a39; "
            f"border-radius: 5px;"
        )
        label.setStyleSheet(style)